package EH.BaekJoon.BinarySearch.Wrong;
import java.util.Scanner;

public class SearchKIndex {
    static long N,K,findNum;
    public static void main(String[] args) {
    	/*
  		  구성 : int[][] A = new int[N][N]; 
  		  	   - A배열의 value들은  i*j로 이루어 져있다.  
  		  	  int[] B = new int[N*N];
  		  	   - B배열은 A배열의 value들이 오름차순으로 정리되어 있다. 
  		  	   
  		   전제 1번 : K인데스 >= B[K] (단, B배열은 인덱스는 1로 시작해야 되고, B배열은 오름차순이어야 한다.)
  		 전제 1번을 통해 알 수 있는 것은 B배열의 값은 항상 K인덱스 이하라는 점입니다. 
  		 결국은 내가 찾고 싶은 B[K]는 K인덱스 이하이기 때문에 1~K까지의 범위를 검색해 B[검색한 범위]의 값을 가져온다면 그것이 정답이 되는 것이라고 생각했습니다.
  		 
  		 전제 1번을 증명    		   
  		   1 2	<-- A 이차원 배열 value값(정렬 없음)
  		   2 4
  		   
  		   1 2 2 4 <-- B 배열에 들어가는 value, A 이차원 배열 value를 오름차순으로 일렬화 한것임
  		   1 2 3 4 <-- B 배열의 인덱스(현재 B배열 인덱스의 시작은 1임)
		   0 1 2 3 <-- B 배열의 인덱스가 0으로 시작할 경우 가정( 0으로 시작하면 전제 1번이 틀림 )
  		   -----------------------------
    	   
    	   1 2 3	<-- A 이차원 배열 value값(정렬 없음)
    	   2 4 6
    	   3 6 9
    	   
    	   1 2 2 3 3 4 6 6 9 <-- B 배열에 들어가는 value, A 이차원 배열 value를 오름차순으로 일렬화 한것임
    	   1 2 3 4 5 6 7 8 9 <-- B 배열의 인덱스(현재 B배열 인덱스의 시작은 1임)
    	   0 1 2 3 4 5 6 7 8 <-- B 배열의 인덱스가 0으로 시작할 경우 가정( 0으로 시작하면 전제 1번이 틀림 )
    	   -------------------------------------
    	   
    	   1 2  3  4	<-- A 이차원 배열 value값(정렬 없음)
    	   2 4  6  8
    	   3 6  9 12
    	   4 8 12 16
    	   
    	  1 2 2 3 3 4 4 4 6  6  8  8  9 12 12 16 <-- B 배열에 들어가는 value, A 이차원 배열 value를 오름차순으로 일렬화 한것임
    	  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 <-- B 배열의 인덱스(현재 B배열 인덱스의 시작은 1임)   	 
    	  0 1 2 3 4 5 6 7 8  9 10 11 12 13 14 15 <-- B 배열의 인덱스가 0으로 시작할 경우 가정( 0으로 시작하면 전제 1번이 틀림 )
    	  --------------------------------------------  
    	   
    	   1  2  3  4   5	<-- A 이차원 배열 value값(정렬 없음)
    	   2  4  6  8  10
    	   3  6  9  12 15
    	   4  8  12 16 20
    	   5  10 15 20 25
    	 
    	 1 2 2 3 3 4 4 4 5  5  6  6  8  8  9 10 10 12 12 15 15 16 20 20 25 <-- B 배열에 들어가는 value, A 이차원 배열 value를 오름차순으로 일렬화 한것임
    	 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 <-- B 배열의 인덱스(현재 B배열 인덱스의 시작은 1임)
    	 0 1 2 3 4 5 6 7 8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 <-- B 배열의 인덱스가 0으로 시작할 경우 가정 ( 0으로 시작하면 전제 1번이 틀림 )
    	 -------------------------------------------------------------------
    	 
    	  1  2  3  4  5  6 	<-- A 이차원 배열 value값(정렬 없음)
    	  2  4  6  8 10 12
    	  3  6  9 12 15 18
    	  4  8 12 16 20 24
    	  5 10 15 20 25 30
    	  6 12 18 24 30 36
    	  
    	  1 2 2 3 3 4 4 4 5  5  6  6  6  6  8  8  9 10 10 12 12 12 12 15 15 16 18 18 20 20 24 24 25 30 30 36 <-- B 배열에 들어가는 value, A 이차원 배열 value를 오름차순으로 일렬화 한것임
    	  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 <-- B 배열의 인덱스(현재 B배열 인덱스의 시작은 1임)
    	  0 1 2 3 4 5 6 7 8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 <-- B 배열의 인덱스가 0으로 시작할 경우 가정( 0으로 시작하면 전제 1번이 틀림 )
    	  
  		   전제 2번 : 찾고자 하는 값을 얻고, 1 ~ K 까지 For문을 돌려 찾고자하는 값(mid)과 같거나 작은 수들을 count한다.
		 찾고자 하는 값(mid)이 4라고 가정했을 때 
		  2차원 배열      찾고자 하는 값          인덱스 count
		   1 2 3       4			3
    	   2 4 6       4 		    2
    	   3 6 9       4			1
		 첫번째 행의 1 2 3은 모두 4 안에 포함되고 인덱스 count는 3이다.
		 두번째 행의 2 4만 4안에 포함되고 인덱스 count는 2이다.
		 세번째 행의 3만 4안에 포함되고 인덱스 count는 1이다.
		 
		   1 2 2 3 3 (4) 6 6 9 <-- B 배열에 들어가는 value, A 이차원 배열 value를 오름차순으로 일렬화 한것임
    	   1 2 3 4 5 (6) 7 8 9 <-- B 배열의 인덱스(현재 B배열 인덱스의 시작은 1임)
		 
		 그래서 각각 나온 값들의 갯수를 세면 총 6개가 되고 B 배열을 오름차순으로 정리했을 떄 4는 6번째 인덱스에 있다는 것을 확인 할 수 있다. 
		 
		 그렇다면 어떻게 인덱스를 구할 수 있을까?
		 
		 이차원 배열인 A의 각 행들의 값은 오름차순으로 정리되어 있다. 
		 
		   1 2 3 <-- 첫번째 행의 원소들은 1,2,3
    	   2 4 6 <-- 두번째 행의 원소들은 2,4,6
    	   3 6 9
		 
		 하지만 첫번째 행의 원소들과 두번째 행의 원소들의 값을 각각 비교했을때 첫번째 행의 모든 원소가 두번째 행의 특정 원소 보다 작지는 않다.
		 예를 들어서 첫번째 행의 3은 두번째 행의 2보다 작지는 않다. 즉 하나의 행값만을 대상으로 해서  인덱스 count를 구할 수 없다.
		 
		 결국은 찾고자 하는 값(mid)을 모든 행에 넣어서 비교를 해봐야지만 정확한 인덱스의 값을 구할 수 있다. 
		     1열 2열 3열
		  1행  1  2  3 + 찾고자 하는 값(mid)
    	  2행  2  4  6 + 찾고자 하는 값(mid)
    	  3행  3  6  9 + 찾고자 하는 값(mid)
		
		현재 이차원 배열의 구성은 위와 같다.
		
				  인덱스 count 범위       찾고자 하는 값
 		   	    1열        2열        3열                           -->      (행 *열)/행                         찾고자 하는 값/행     --> 인덱스 count 범위   인덱스 count
    	 	1행 (1*1) (1*2) (1*3)     4    --> (1*1)/1 (1*2)/1 (1*3)/1       4/1     -->      1 2 3        4 ( 인덱스 count 범위 초과 --> 3으로 변경 )
    	 	2행 (2*1) (2*2) (2*3)     4    --> (2*1)/2 (2*2)/2 (2*3)/2       4/2     -->      1 2 3        2
    	 	3행 (3*1) (3*2) (3*3)     4    --> (3*1)/3 (3*2)/3 (3*3)/3       4/3     -->      1 2 3        1
    	 	
		기존의 이차원 배열의 구성은 위와 같이 i*j 형태로 되어 있다. 
		여기서 이차원 배열의 열을 인덱스 count 범위라고 하고, 비교를 위해 찾고자 하는 값(mid)을 각 행에 넣는다고 생각을 해보자 
		각 행별 값들을 인덱스 count 범위와 인덱스 count로 구하기 위해서는 각 행별 값에서 행을 나누어 주어야 한다.
		예를 들어 4가 포함된 2번째 행의 경우 2 4 6 4에서, 행으로 나누면 1 2 3 2 가 된다. 		
		그러면 자연스럽게 인덱스 count 범위와 인덱스 count의 값이 나온다. 
		만약 인덱스 count가 인덱스 count 범위를 초과했다면 인덱스 count 범위에서 큰값을 가져오면 되고
		인덱스 count 범위 내라면 인덱스 count 값을 유지한다. 마지막으로 각 인덱스 count 값을 모두 더한다.
		
		마지막으로 K보다 인덱스 count합이 크거나 같을 경우 찾고자 하는 값(mid)을 답으로 하고 end = mid -1, 인덱스 count 합이 K보다 작을 경우 start = mid + 1; 해준다. 		
		count합이 크거나 같을 경우 찾고자 하는 값(mid)을 답으로 하는 이유는 B배열의 값은 중복이 있을 수 있기 때문이다.
		
		
		1 2 2 3 3 4 6 6 9 <-- B 배열에 들어가는 value, A 이차원 배열 value를 오름차순으로 일렬화 한것임
    	1 2 3 4 5 6 7 8 9 <-- B 배열의 인덱스(현재 B배열 인덱스의 시작은 1임)
		
		예를 들어 N이 3이면서 K가 7인 인덱스를 뽑을 때 
		start mid end 인덱스 count 합
		  1    4   7       6
		  5    6   7       8
          5    5   5       6
		최종적으로 인덱스 count 합이 8로 나온다. 8로 나오는 이유는 B배열의 숫자 값이 겹쳐서 그렇게 나온것
		경우에 따라서 인덱스 count 합과 K가 딱맞게 나올수도 있고 아니면 그것보다 높게 나올 수 도 있음(인덱스 count 합 >= K 라고 생각하면 됨)
  
    	 */
		Scanner scan = new Scanner(System.in);
    	N = scan.nextInt();
    	K = scan.nextInt();  
        
        binarySearch(1,K);
        System.out.println(findNum);
    }
	
	public static void binarySearch(long start, long end) {
		if(start > end) return;
		long mid = (start + end) / 2;
		long KIndex = 0;
		
		for(long i = 1; i <= N; i++) KIndex += Math.min(mid/i, N);
		
		System.out.println(start + " " + mid + " " + end + " " + KIndex);
		
		if(KIndex >= K) {			
			findNum = mid;
			binarySearch(start, mid - 1);			
		}else binarySearch(mid + 1, end);			
		return;	
	}
	
}